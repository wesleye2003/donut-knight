// This is a manifest file that'll be compiled into application.js, which will include all the files
// listed below.
//
// Any JavaScript/Coffee file within this directory, lib/assets/javascripts, vendor/assets/javascripts,
// or any plugin's vendor/assets/javascripts directory can be referenced here using a relative path.
//
// It's not advisable to add code directly here, but if you do, it'll appear at the bottom of the
// compiled file.
//
// Read Sprockets README (https://github.com/rails/sprockets#sprockets-directives) for details
// about supported directives.
//
//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
//= require phaser.min


var game = new Phaser.Game(800, 600, Phaser.AUTO, 'donut-knight', { preload: preload, create: create, update: update });

function preload() {
  game.load.spritesheet('knight', "<%= asset_path('chara7.png') %>", 32, 32);
  game.load.spritesheet('boss', "<%= asset_path('bigmonster1.gif') %>", 80, 80, 11);
  game.load.image('bullet', "<%= asset_path('donut.gif') %>");
  game.load.spritesheet('background', "<%= asset_path('map0.png') %>", 16, 16, 28);
}

var knight;
var boss;
var bullets;
var bulletTime = 0;
var bullet;


var attackingDirection;
function create() {
	game.physics.startSystem(Phaser.Physics.ARCADE);

	game.add.tileSprite(0, 0, 800, 600, 'background', 8);

  knight = game.add.sprite(game.world.centerX-100, game.world.centerY, 'knight');
  knight.anchor.setTo(0.5, 0.5);
  knight.scale.setTo(2, 2);
  game.physics.arcade.enable(knight, Phaser.Physics.ARCADE)

  boss = game.add.sprite(game.world.centerX+150, game.world.centerY, 'boss');
  boss.health = 10;
  boss.anchor.setTo(0.5, 0.6);
  boss.scale.setTo(2, 2);
  game.physics.arcade.enable(boss, Phaser.Physics.ARCADE)
  boss.body.immovable = true;
  bullets = game.add.group();
  bullets.enableBody = true;
  bullets.physicsBodyType = Phaser.Physics.ARCADE;

  for (var i = 0; i < 20; i++){
    var b = bullets.create(0, 0, 'bullet');
    b.name = 'bullet' + i;
    b.anchor.setTo(0.5, 0.5);
    b.exists = false;
    b.visible = false;
    b.checkWorldBounds = true;
    b.events.onOutOfBounds.add(resetBullet, this);
  }


  knight.animations.add('walkDown', [3,4,5,4]);

  knight.animations.add('attackDown', [6, 7, 8, 3]);

  knight.animations.add('walkLeft', [12,13,14,13]);

  knight.animations.add('attackLeft', [15, 16, 17, 12]);

  knight.animations.add('walkRight', [21,22,23,22]);

  knight.animations.add('attackRight', [24, 25, 26, 21]);

  knight.animations.add('walkUp', [30,31,32,31]);

  knight.animations.add('attackUp', [33, 34, 35, 30]);

  knight.animations.add('victorious', [1, 1, 1, 6, 7, 16, 34, 25, 6, 7, 7, 8])

  knight.animations.add('spin', [1, 10, 28, 19, 1])

  boss.animations.add('rise', [ 0, 0, 0, 1, 1, 4, 4, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 10, 10, 10, 10, 10, 10, 4, 4, 6]);

  boss.animations.add('neutral', [4])

  boss.animations.add('flinch', [5, 7, 10]);

  boss.animations.add('die', [10, 5, 7, 10, 1, 0]);

  knight.animations.play('spin', 6, false)

  boss.animations.play('rise', 8, false);

}

function update() {
  game.physics.arcade.collide(knight, boss)
	game.physics.arcade.overlap(bullet, boss, collisionHandler, null, this);
	knight.body.velocity.x = 0;
  knight.body.velocity.y = 0;

  if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT)){
    knight.animations.play('walkLeft', 5, false);
    knight.body.velocity.x = -200;
    attackingDirection = "attackLeft"
  }
  else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT)){
    knight.animations.play('walkRight', 5, false);
    knight.body.velocity.x = 200;
    attackingDirection = "attackRight";
  }
  else if (game.input.keyboard.isDown(Phaser.Keyboard.UP)){
    knight.animations.play('walkUp', 5, false);
    knight.body.velocity.y = -200;
    attackingDirection = "attackUp";
  }
  else if (game.input.keyboard.isDown(Phaser.Keyboard.DOWN)){
    knight.animations.play('walkDown', 5, false);
    knight.body.velocity.y = 200;
    attackingDirection = "attackDown";
  }



  if (game.input.keyboard.isDown(Phaser.Keyboard.SPACEBAR)){
    fireBullet(attackingDirection);
    knight.animations.play(attackingDirection, 8, false);
  }

}

function resetBullet (bullet) {
  bullet.kill();
}

function fireBullet(direction) {
  if (game.time.now > bulletTime){
    bullet = bullets.getFirstExists(false);
    game.add.tween(bullet).to( { angle: 360 }, 2000, Phaser.Easing.Linear.None, true);
    if (bullet){
      if (direction == "attackLeft"){
        bullet.reset(knight.x - 5, knight.y);
        bullet.body.velocity.x = -400;
        bulletTime = game.time.now + 1000;
      }else if (direction == "attackRight"){
      	bullet.reset(knight.x + 5, knight.y);
        bullet.body.velocity.x = 400;
        bulletTime = game.time.now + 1000;
      }else if (direction == "attackUp"){
      	bullet.reset(knight.x, knight.y - 5);
        bullet.body.velocity.y = -400;
        bulletTime = game.time.now + 1000;
      }else if (direction == "attackDown"){
      	bullet.reset(knight.x, knight.y + 5);
        bullet.body.velocity.y = 400;
        bulletTime = game.time.now + 1000;
      }
    }
  }
}

function collisionHandler (bullet, boss) {
	bullet.kill();
	boss.animations.play('flinch', 5, false);
  boss.health -= 1;
  if (boss.health <= 0){
  	game.input.keyboard.destroy();
  	knight.body.velocity.x = 0;
  	knight.body.velocity.y = 0;
  	boss.animations.play('die', 5, false);
  	setTimeout(function(){
    	boss.kill();
    	knight.animations.play('victorious', 7, false);
		}, 2000);
  }
}